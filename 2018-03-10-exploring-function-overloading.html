<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Casper's Blog ‚Äì Exploring Function Overloading</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <div class="layout">
    <!-- Sidebar -->
    <aside class="sidebar">
      <h1 class="blog-title"><a href="index.html">Casper's Blog</a></h1>
      <p class="tagline">Thoughts on code, systems, and craft.</p>
      <div class="socials">
        <a href="https://github.com/CasualX">GitHub</a>
      </div>
    </aside>

    <!-- Blog post -->
    <main class="post">


<article>
  <h1>Exploring Function Overloading</h1>
  <div class="meta"><span class="date">Mar 10, 2018</span> ‚Äî <span class="author">by Casper</span> ‚Äî <span class="tags-inline">rust</span></div>
<p>Overloading is the ability to create multiple functions of the same name with different implementations.</p>
<p>Rust has no traditional overloading, you cannot define two methods with the same name. The compiler will complain that you have a duplicate definition regardless of the different argument types.</p>
<p>Trying to be clever with traits also doesn't work:</p>
<pre><code class="language-rust">trait FooA { fn foo(_: i32); }
trait FooB { fn foo(_: &amp;str); }

struct Foo;
impl FooA for Foo { fn foo(_: i32) { println!(&quot;FooA&quot;); } }
impl FooB for Foo { fn foo(_: &amp;str) { println!(&quot;FooB&quot;); } }
</code></pre>
<p>Then try to call the function with a <code>&amp;str</code> argument type:</p>
<pre><code class="language-rust">fn main() {
	Foo::foo(&quot;hello&quot;);
}
</code></pre>
<p>This won't compile because the invocation is ambiguous and Rust doesn't try to figure out which one to call based on argument types. If we run this code, the compiler reports that there are multiple applicable items in scope.</p>
<p>Instead this example requires an explicit disambiguation:</p>
<pre><code class="language-rust">fn main() {
	&lt;Foo as FooB&gt;::foo(&quot;hello&quot;);
}
</code></pre>
<p><a href="https://play.rust-lang.org/?gist=9df9128c20b9c612806223dd91a70de0&amp;version=stable">Playground</a></p>
<p>However, that defeats the point of overloading.</p>
<p>At the end of this blog post I will show that Rust can get pretty close to traditional overloading through the use of its trait system and generics.</p>
<h2>Static polymorphism</h2>
<p>Rust uses static polymorphism with generics to allow a method to take different types of arguments.</p>
<p>The generic parameter is constrained by a trait meaning that the function will only accept types which implement that trait. The trait limits what you can do with the argument.</p>
<p>They can be very simple things like <code>AsRef</code> to make your API more accepting like so:</p>
<pre><code class="language-rust">fn print_bytes&lt;T: AsRef&lt;[u8]&gt;&gt;(bytes: T) {
	println!(&quot;{:?}&quot;, bytes.as_ref());
}
</code></pre>
<p>At the call site it certainly looks like overloading:</p>
<pre><code class="language-rust">fn main() {
	print_bytes(&quot;hello world&quot;);
	print_bytes(&amp;[12, 42, 39, 15, 91]);
}
</code></pre>
<p><a href="https://play.rust-lang.org/?gist=7286491e1d741d0817eb7868bb1d41fc&amp;version=stable">Playground</a></p>
<p>Perhaps the best demonstration of this is <a href="https://doc.rust-lang.org/std/string/trait.ToString.html">the <code>ToString</code> trait</a> which accepts a whole host of types:</p>
<pre><code class="language-rust">fn print_str&lt;T: ToString&gt;(value: T) {
	let s = value.to_string();
	println!(&quot;{}&quot;, s);
}

fn main() {
	print_str(42);
	print_str(3.141593);
	print_str(&quot;hello&quot;);
	print_str(true);
	print_str('üòé');
}
</code></pre>
<p><a href="https://play.rust-lang.org/?gist=a02e3e28783ddc33ff07ec92db600422&amp;version=stable">Playground</a></p>
<p>This kind of overloading makes your API more accessible for your users. They won't be burdened by ensuring the arguments are converted to the correct type your API expects, you'll do it for them. The result is an API which is more pleasant to use.</p>
<p>This approach has a major advantage over traditional overloading that by implementing the required traits makes your API accept the user's custom types.</p>
<p>Traditional overloading offers a lot more flexibility in the implementation and the number of arguments of the overloaded functions. That last point can be aleviated by using tuples as a stand-in for multiple arguments but it's not so pretty. An example of this can be found in <a href="https://doc.rust-lang.org/std/net/trait.ToSocketAddrs.html#implementors">the <code>ToSocketAddrs</code> trait</a> in the standard library.</p>
<h2>Intermezzo: Generics code bloat</h2>
<p>Beware of '<em>generics code bloat</em>' when using generics. If you have a generic function with significant amount of non trivial code, a new copy of that function specialized for every unique set of type arguments is created. Even if all you do is convert the input arguments at the start of the function.</p>
<p>Luckily there's a simple solution to this problem: implement a private function without generics accepting the real types you want to work with then have your public generic method perform the type conversions and dispatch to your private implementation:</p>
<pre><code class="language-rust">mod stats {
	pub fn stddev&lt;T: ?Sized + AsRef&lt;[f64]&gt;&gt;(values: &amp;T) -&gt; f64 {
		stddev_impl(values.as_ref())
	}
	fn stddev_impl(values: &amp;[f64]) -&gt; f64 {
		let len = values.len() as f64;
		let sum: f64 = values.iter().cloned().sum();
		let mean = sum / len;
		let var = values.iter().fold(0f64, |acc, &amp;x| acc + (x - mean) * (x - mean)) / len;
		var.sqrt()
	}
}
pub use stats::stddev;
</code></pre>
<p>Despite being called with two different types (<code>&amp;[f64]</code> and <code>&amp;Vec&lt;f64&gt;</code>) the meat of the function is only implemented once, saving on binary size:</p>
<pre><code class="language-rust">fn main() {
	let a = stddev(&amp;[600.0, 470.0, 170.0, 430.0, 300.0]);
	let b = stddev(&amp;vec![600.0, 470.0, 170.0, 430.0, 300.0]);

	assert_eq!(a, b);
}
</code></pre>
<p><a href="https://play.rust-lang.org/?gist=91dd76eca898115a3bea4dc39d1695c9&amp;version=stable">Playground</a></p>
<h2>Stretching to the limit</h2>
<p>Not all overloading falls into this category of convenient argument conversion. Sometimes you really want to handle different types in a unique non-uniform way.
For these occasions you can define your own trait to implement the function's custom logic:</p>
<pre><code class="language-rust">pub struct Foo(bool);

pub trait CustomFoo {
	fn custom_foo(self, this: &amp;Foo);
}
</code></pre>
<p>This makes the trait very awkward as the <code>self</code> and arguments are swapped:</p>
<pre><code class="language-rust">impl CustomFoo for i32 {
	fn custom_foo(self, this: &amp;Foo) {
		println!(&quot;Foo({}) i32: {}&quot;, this.0, self);
	}
}
impl CustomFoo for char {
	fn custom_foo(self, this: &amp;Foo) {
		println!(&quot;Foo({}) char: {}&quot;, this.0, self);
	}
}
impl&lt;'a, S: AsRef&lt;str&gt; + ?sized&gt; CustomFoo for &amp;'a S {
	fn custom_foo(self, this: &amp;Foo) {
		println!(&quot;Foo({}) str: {}&quot;, this.0, self.as_ref());
	}
}
</code></pre>
<p>The trait cannot be hidden as an implementation detail that isn't exposed to API users. If you try to make the trait private then the compiler will complain about 'private trait in public interface'.</p>
<p>Let's provide a wrapper for the trait so it doesn't have to be called through the argument type:</p>
<pre><code class="language-rust">pub struct Foo(bool);

impl Foo {
	pub fn foo&lt;T: CustomFoo&gt;(&amp;self, arg: T) {
		arg.custom_foo(self);
	}
}

fn main() {
	Foo(false).foo(13);
	Foo(true).foo('üòÜ'));
	Foo(true).foo(&quot;baz&quot;);
}
</code></pre>
<p><a href="https://play.rust-lang.org/?gist=83347c7604dc08886f32cdd1395a889e&amp;version=stable">Playground</a></p>
<p>An example of this technique can be found in the standard library in <a href="https://doc.rust-lang.org/std/str/pattern/trait.Pattern.html">the <code>Pattern</code> trait</a> used by various string matching <a href="https://doc.rust-lang.org/std/primitive.str.html#method.find">functions like <code>str::find</code></a>.</p>
<p>Unlike you, the standard library has special powers to hide these traits while still allowing them to be used in its public interface through the <code>#[unstable]</code> attribute.</p>
<h2>Have your cake and eat it too</h2>
<p>There is a better way, that gets us almost all the way to traditional overloading.</p>
<p>Define the trait for the method you would like to overload, with generic parameters for all the parameters you'd like to be able to change through overloading:</p>
<pre><code class="language-rust">trait OverloadedFoo&lt;T, U&gt; {
	fn overloaded_foo(&amp;self, tee: T, yu: U);
}
</code></pre>
<p>Rust's trait constraints with where clauses are incredibly powerful.</p>
<p>When implementing the method, simply constrain <code>Self</code> to implement the trait and any generic parameters your trait needs. This is enough for Rust to figure everything out:</p>
<pre><code class="language-rust">struct Foo;
impl Foo {
	fn foo&lt;T, U&gt;(&amp;self, tee: T, yu: U) where Self: OverloadedFoo&lt;T, U&gt; {
		self.overloaded_foo(tee, yu)
	}
}
</code></pre>
<p>Then implement the trait for all the types you wish to provide an overload for:</p>
<pre><code class="language-rust">impl OverloadedFoo&lt;i32, f32&gt; for Foo {
	fn overloaded_foo(&amp;self, tee: i32, yu: f32) {
		println!(&quot;foo&lt;i32, f32&gt;(tee: {}, yu: {})&quot;, tee, yu);
	}
}
</code></pre>
<p>These can be blanket impls. Although be careful to not run into trait coherence errors. The compiler's error messages are extremely helpful here.</p>
<pre><code class="language-rust">impl&lt;'a, S: AsRef&lt;str&gt; + ?Sized&gt; OverloadedFoo&lt;&amp;'a S, char&gt; for Foo {
	fn overloaded_foo(&amp;self, tee: &amp;'a S, yu: char) {
		println!(&quot;foo&lt;&amp;str, char&gt;(tee: {}, yu: {})&quot;, tee.as_ref(), yu);
	}
}
</code></pre>
<p>That's it!</p>
<p>Try to uncomment last line and observe the helpful error message when the function is called with types the overload doesn't support:</p>
<pre><code class="language-rust">fn main() {
	Foo.foo(42, 3.14159);
	Foo.foo(&quot;hello&quot;, 'üòÑ');
	// Foo.foo('üòè', 13); // the trait bound is not satisfied
}
</code></pre>
<p><a href="https://play.rust-lang.org/?gist=880fae763e1c7c6f3b7c8619b6c97867&amp;version=stable">Playground</a></p>
<h2>Final notes</h2>
<p>As always, which technique you choose to achieve overloading depends on your specific needs. My goal with this blog post is to lay out the different overloading techniques and their limitations so you can make an informed decision for your codebase.</p>
<p>I haven't experimented yet with specialization and how it will affect these techniques. My impression is that specialization seeks to solve an orthogonal problem and nothing will prevent specialization combined with overloading as described here.</p>
<p>Feel free to experiment!</p>
<p>If you're still reading this I hope you've enjoyed this exploration of function overloading in Rust and its limitations.</p>

</article>

      <!-- Footer -->
      <footer class="footer">
        <p>¬© 2018 Casper ‚Äî Content licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></p>
      </footer>
    </main>
  </div>
</body>
</html>
